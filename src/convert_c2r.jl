module ConvertC2R

using Polynomials4ML, SparseArrays, LinearAlgebra, NamedTupleTools
P4ML = Polynomials4ML

"""
transform from real to complex spherical harmonics bases as they are 
implemented in P4ML. 
"""
function r2c_transform(L)
   T = zeros(ComplexF64, (L+1)^2, (L+1)^2)
   for l = 0:L 
      # m = 0
      i_l0 = P4ML.lm2idx(l, 0)
      T[i_l0, i_l0] = 1.0 
      for m = 1:l
         i_lm  = P4ML.lm2idx(l,  m)
         i_l⁻m = P4ML.lm2idx(l, -m)
         T[ i_lm,  i_lm] = 1/sqrt(2) 
         T[ i_lm, i_l⁻m] = -im/sqrt(2) 
         T[i_l⁻m,  i_lm] = (-1)^m/sqrt(2) 
         T[i_l⁻m, i_l⁻m] = (-1)^m*im/sqrt(2) 
      end
   end
   return sparse(T)
end

"""
transform between real spherical harmonics bases, from 
SpheriCart to P4ML convention. 
"""
function sc2p4_transform(L) 
   D = zeros((L+1)^2)
   for l = 0:L
      for m = -l:-1
         i_lm = P4ML.lm2idx(l, m)
         D[i_lm] = (-1)^(m+1)
      end
      i_l0 = P4ML.lm2idx(l, 0)
      D[i_l0] = 1
      for m = 1:l
         i_lm = P4ML.lm2idx(l, m)
         D[i_lm] = (-1)^(m)
      end
   end
   return Diagonal(D)
end

"""
this converts a transform matrix to a dictionary which is 
easier to use when construcing the transforms for tensor products 
"""
function _dict_Ylm_transform(TT::AbstractMatrix{T}) where {T} 
   L = round(Int, sqrt(size(TT, 1)) - 1)
   @assert (L+1)^2 == size(TT, 1) == size(TT, 2)
   D = Dict{Tuple{Int, Int}, Vector{Tuple{Int, T}}}()
   for l = 0:L
      for m = -l:l
         i_lm = P4ML.lm2idx(l, m)
         inz = findall(!iszero, TT[i_lm, :])
         D_lm = D[(l, m)] = Tuple{Int, T}[] 
         for i in inz
            m_i = P4ML.idx2lm(i)[2]
            push!(D_lm, (m_i, TT[i_lm, i]))
         end
      end
   end
   return D 
end

"""
transform an A basis 
- `spec_c` : complex A basis spec `(z = .., n = .., l = .., m = ..)[]`
- `D_T` : dict of the Ylm transform; cf. `_dict_Ylm_transform`
"""
function _A_transform(spec_c, spec_r, D_T; cache = Dict())
   # first construct the real spec and inverse specs 
   # the real spec in this case could be identical to the complex spec 
   NT = eltype(spec_c)
   inv_spec_c = Dict{NT, Int}()
   inv_spec_r = Dict{NT, Int}()
   for i = 1:length(spec_c)
      inv_spec_c[spec_c[i]] = i
      inv_spec_r[spec_r[i]] = i
   end

   # now we create a triplet-format sparse matrix
   rows = Int[]; cols = Int[]; vals = Any[]
   for (i_c, b) in enumerate(spec_c) 
      T_lmk = D_T[(b.l, b.m)] 
      for (k, t) in T_lmk 
         i_r = inv_spec_r[(z = b.z, n = b.n, l = b.l, m = k)]
         push!(rows, i_c)
         push!(cols, i_r)
         push!(vals, t)
      end
   end

   return sparse(rows, cols, identity.(vals))
end

""" 
construct the transform of tensor products
- `D_T` : dict of the Ylm transform; cf. `_dict_Ylm_transform`
- `cache` : dict of cached product transforms 
- `f` : transform the coefficient, usually identity or real 
     use real for transforming ACE1 type models 
""" 
function _prodYlm_transform(ll, mm, D_T::Dict; 
                            cache = Dict(), 
                            f = identity)
   if cache == nothing 
      cache = Dict()
   end

   if haskey(cache, (ll, mm))
      TT = cache[(ll, mm)]

   else 

      N = length(ll) 
      if N == 1 
         D_lm_ = D_T[(ll[1], mm[1])]
         D_lm = [ ((m,), t) for (m, t) in D_lm_ ]
         return D_lm, cache
      end 

      # recursively compute the N-1 product 
      ll1 = ll[1:N-1]
      mm1 = mm[1:N-1]
      TT1, cache = _prodYlm_transform(ll1, mm1, D_T; cache = cache)

      # now loop over the last piece 
      TT = []
      lN = ll[N]; mN = mm[N]
      T_lmk = D_T[(lN, mN)]  # vector of (k, T_lmk) pairs 
      for (kk1, t1) in TT1 
         for (kN, t) in T_lmk 
            push!(TT, (tuple(kk1..., kN), t1*t))
         end
      end
      TT = identity.(TT)
      cache[(ll, mm)] = TT
   end

   # remove zeros from TT 
   TTnew = [ (ll, f(t)) for (ll, t) in TT if abs(f(t)) > 1e-14 ]

   return TT, cache 
end


"""
Starting from the spec of a complex AA basis, this generates the spec of a 
real AA basis and the transformation matrix between the two. 

- `spec_c` must be given as a `Vector{Vector{<: NamedTuple}}` where each 
  `NamedTuple` must have `l, m` entries. 
- `D_T` is the transform dictionary generated by `_dict_Ylm_transform`, 
  converting the spherical harmonics 
- `f` is a transorm, usually `real`
- `cache` need not be passed in
"""
function _AA_r2c_transform(spec_c, D_T; f = identity, cache = Dict())
   
   # first we need to generate the spec of the real AA basis 
   NT = eltype(eltype(spec_c))
   spec_r = Vector{Vector{NT}}(undef, 0)

   labels = fieldnames(NT)
   @assert labels[end-1] == :l 
   @assert labels[end] == :m 
   labels_m = labels[1:end-1] 
   LENNT = length(labels)
   NTPROTO = namedtuple(labels)

   for bb_c in spec_c 
      N = length(bb_c)
      ll = getindex.(bb_c, :l)
      mm = getindex.(bb_c, :m)
      tt, cache = _prodYlm_transform(ll, mm, D_T; cache=cache)
      for t in tt 
         kk = t[1] 
         if abs(f(t[2])) > 1e-12 
            bb_r = [  NTPROTO([bb_c[i][a] for a in labels_m]..., kk[i])
                     for i = 1:length(kk) ]
            push!(spec_r, bb_r)
         end
      end
   end

   # complete the AA basis spec 
   spec_r = sort(unique(spec_r))
   spec_r = sort(spec_r, by = length)

   # compute the inverse specification for both 
   inv_spec_c = Dict{Any, Int}() 
   for i = 1:length(spec_c)
      inv_spec_c[spec_c[i]] = i
   end
   inv_spec_r = Dict{Any, Int}()
   for i = 1:length(spec_r)
      inv_spec_r[spec_r[i]] = i
   end

   # now we create a triplet-format sparse matrix 
   rows = Int[]; cols = Int[]; vals = Any[]

   for bb_c in spec_c 
      N = length(bb_c)
      ll = getindex.(bb_c, :l)
      mm = getindex.(bb_c, :m)
      tt, cache = _prodYlm_transform(ll, mm, D_T; cache=cache)
      for t in tt 
         kk = t[1] 
         coeff = f(t[2])
         if abs(coeff) > 1e-12 
            bb_r = [  NTPROTO([bb_c[i][a] for a in labels_m]..., kk[i])
                     for i = 1:length(kk) ]
            i_c = inv_spec_c[bb_c]
            i_r = inv_spec_r[bb_r]
            push!(rows, i_c)
            push!(cols, i_r)
            push!(vals, coeff)
         end
      end
   end

   # need better sorting here 
   return Dict(:spec_c => spec_c, 
               :spec_r => spec_r,
               :inv_spec_c => inv_spec_c,
               :inv_spec_r => inv_spec_r,
               :T => sparse(rows, cols, identity.(vals)))
end


end
